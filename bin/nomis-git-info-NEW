#!/usr/bin/env bash

#### Options and usage

script=$(basename ${BASH_SOURCE[0]})

# Switches
main_heading=
print_main_heading_if_nothing_to_print=
print_branch_p=
print_branch_if_not_master_p=
print_short_status_if_clean_p=
print_ahead_or_behind_branches_if_none_p=
print_local_branches_with_no_remote_if_none_p=

usage() {
    echo "Usage:"
    echo ""
    echo "$(basename ${BASH_SOURCE[0]}) [options]"
    echo ""
    echo "options:"
    echo "-h             Print this help"
    echo "-s <heading>   A heading, printed only if any output is produced"
    echo "-b             Include 'branch name'  section"
    echo "-m             Include 'branch name'  section only if branch is not master"
    echo "-c             Include 'status'       section even if repo is clean"
    echo "-d             Include 'ahead/behind' section even if no branches are ahead/behind"
    echo "-r             Include 'no remotes'   section even if all branches have a remote"
    echo "-v             Verbose; equivalent to -bcdr"
}

while getopts "hs:pmbcdrv" option; do
    case "${option}" in
        h)
            usage
            exit 0
            ;;
        s)
            main_heading=${OPTARG}
            ;;
        p)
            print_main_heading_if_nothing_to_print="YES"
            ;;
        m)
            print_branch_if_not_master_p="YES"
            ;;
        b)
            print_branch_p="YES"
            ;;
        c)
            print_short_status_if_clean_p="YES"
            ;;
        d)
            print_ahead_or_behind_branches_if_none_p="YES"
            ;;
        r)
            print_local_branches_with_no_remote_if_none_p=="YES"
            ;;
        v)
            print_branch_p="YES"
            print_short_status_if_clean_p="YES"
            print_ahead_or_behind_branches_if_none_p="YES"
            print_local_branches_with_no_remote_if_none_p=="YES"
            ;;
        *)
            usage 1>&2
            exit 1
            ;;
    esac
done

shift $((OPTIND-1))


#### Main functionality

################################################################################
#### Colours

RED=`tput setaf 1`
GREEN=`tput setaf 2`
RESET=`tput sgr0`

HIGHLIGHT=${GREEN}
NORMAL=${RESET}

################################################################################


function echo_heading {
    echo -e "${HIGHLIGHT}${1}${NORMAL}"
}

function echo_subheading {
    echo -e "${HIGHLIGHT}----${1}${NORMAL}"
}

main_heading_printed_p=

function print_main_heading_if_not_already_done {
    if [[ ! "${main_heading_printed_p}" ]] ; then
        if [[ ${main_heading} ]] ; then
            echo_heading "________________________________________________________________________________"
            echo_heading "${main_heading}"
        fi
        main_heading_printed_p="YES"
    fi
}

function maybe_print_branch {
    local heading="$1"
    local branch="$2"
    if [[ "${print_branch_p}" \
              || ( "${branch}" != "master" \
                       && "${print_branch_if_not_master_p}" ) ]]
    then
        # TODO Add a way to not report certain non-master branches.
        #      - To reproduce the functionality that is/was in
        #        "nomis-git-mega-status-v2".
        #        Perhaps a file with lines that are repo / branch pairs.
        # echo_subheading "${heading}"
        if [[ ! ( "${branch}" == "putting-this-here-so-i-can-align-things" \
                      || "${branch}" == "tutorial-18" \
                      || "${branch}" == "nomis" \
                      || "${branch}" == "nomis-0-10-0" \
                      || "${branch}" == "simon-post-dojo-stuff" \
                ) ]]
        then
            print_main_heading_if_not_already_done
            echo "Current branch: ${branch}"
        fi
    fi
}

function maybe_print_short_status {
    local output=$(git status --short) # Adding `--branch` would mention the branch and whether ahrad/behind
    if [[ "${output}" || "${print_short_status_if_clean_p}" ]]
    then
        print_main_heading_if_not_already_done
        echo_subheading "Short status"
        if [[ "${output}" ]] ; then
            echo "${output}"
        else
            echo "Status is clean"
        fi
    fi
}

function maybe_print_ahead_or_behind_branches {
    local output=$(git branch -vv | grep ahead\\\|behind)
    if [[ "${output}" || "${print_ahead_or_behind_branches_if_none_p}" ]]
    then
        print_main_heading_if_not_already_done
        echo_subheading "Branches that are ahead of or behind the remote"
        if [[ "${output}" ]] ; then
            echo "${output}"
        else
            echo "No branches are ahead or behind"
        fi
    fi
}

function maybe_print_local_branches_with_no_remote {
    local output=$(git branch -vv | cut -c 3- | awk '$3 !~/\[/ { print "Only local: "$1 }')
    local output_2=$(git branch -vv | cut -c 3- | grep "gone\]" | awk '{ print "Only local: " $1 " (but used to have a remote)"}')
    if [[ "${output_2}" ]] ; then
        if [[ "${output}" ]] ; then
            output+=$'\n'
        fi
        output+="${output_2}"
    fi
    if [[ "${output}" || "${print_local_branches_with_no_remote_if_none_p}" ]]
    then
        print_main_heading_if_not_already_done
        echo_subheading "Local branches with no remote"
        if [[ "${output}" ]] ; then
            echo "${output}"
        else
            echo "All branches have a remote"
        fi
    fi
}

current_branch=$(git rev-parse --abbrev-ref HEAD)

if [[ ${print_main_heading_if_nothing_to_print} ]] ; then
    print_main_heading_if_not_already_done
fi

maybe_print_branch "Current Branch" ${current_branch}
maybe_print_short_status
maybe_print_ahead_or_behind_branches
maybe_print_local_branches_with_no_remote
